{"version":3,"sources":["../../../../node_modules/next/src/build/webpack/loaders/next-flight-loader/server-reference.ts","../../../../node_modules/next/src/build/webpack/loaders/next-flight-loader/action-validate.ts","../../../../src/app/dashboard/recipes/actions.ts","../../../../.next-internal/server/app/dashboard/recipes/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["/* eslint-disable import/no-extraneous-dependencies */\nexport { registerServerReference } from 'react-server-dom-webpack/server'\n","// This function ensures that all the exported values are valid server actions,\n// during the runtime. By definition all actions are required to be async\n// functions, but here we can only check that they are functions.\nexport function ensureServerEntryExports(actions: any[]) {\n  for (let i = 0; i < actions.length; i++) {\n    const action = actions[i]\n    if (typeof action !== 'function') {\n      throw new Error(\n        `A \"use server\" file can only export async functions, found ${typeof action}.\\nRead more: https://nextjs.org/docs/messages/invalid-use-server-value`\n      )\n    }\n  }\n}\n","\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\nimport { revalidatePath } from \"next/cache\";\n\ninterface RecipeItemInput {\n  inputItemId: string;\n  quantity: number;\n  unit: string;\n}\n\ninterface CreateRecipeInput {\n  outputItemId: string;\n  outputQuantity: number;\n  items: RecipeItemInput[];\n  name?: string;\n  description?: string;\n}\n\nexport async function createRecipe(data: CreateRecipeInput) {\n  const supabase = await createClient();\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    return { error: \"Unauthorized\" };\n  }\n\n  const { data: userRole } = await supabase\n    .from(\"user_roles\")\n    .select(\"store_id\")\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (!userRole?.store_id) {\n    return { error: \"Store not found\" };\n  }\n\n  const store_id = userRole.store_id;\n  const { outputItemId, outputQuantity, items, name, description } = data;\n\n  // Validation: Circular Reference Check\n  if (items.some((item) => item.inputItemId === outputItemId)) {\n    return { error: \"Self-reference detected: Output item cannot be an ingredient.\" };\n  }\n\n  // 1. Calculate next version\n  const { data: existingRecipes, error: versionError } = await supabase\n    .from(\"recipes\")\n    .select(\"version\")\n    .eq(\"store_id\", store_id)\n    .eq(\"output_item_id\", outputItemId)\n    .order(\"version\", { ascending: false })\n    .limit(1);\n\n  if (versionError) {\n    return { error: `Version check failed: ${versionError.message}` };\n  }\n\n  const nextVersion = existingRecipes && existingRecipes.length > 0\n    ? existingRecipes[0].version + 1\n    : 1;\n\n  // 2. Insert Recipe\n  const { data: recipe, error: recipeError } = await supabase\n    .from(\"recipes\")\n    .insert({\n      store_id,\n      output_item_id: outputItemId,\n      output_quantity: outputQuantity,\n      version: nextVersion,\n      is_active: true,\n      name,\n      description,\n    })\n    .select()\n    .single();\n\n  if (recipeError) {\n    return { error: `Recipe creation failed: ${recipeError.message}` };\n  }\n\n  // 3. Insert Recipe Items\n  if (items.length > 0) {\n    const recipeItems = items.map((item, index) => ({\n      recipe_id: recipe.id,\n      input_item_id: item.inputItemId,\n      quantity: item.quantity,\n      unit: item.unit,\n      sort_order: index,\n    }));\n\n    const { error: itemsError } = await supabase\n      .from(\"recipe_items\")\n      .insert(recipeItems);\n\n    if (itemsError) {\n      // Rollback: delete the recipe if items fail\n      await supabase.from(\"recipes\").delete().eq(\"id\", recipe.id);\n      return { error: `Failed to add ingredients: ${itemsError.message}` };\n    }\n  }\n\n  // 4. Deactivate previous versions\n  const { error: deactivateError } = await supabase\n    .from(\"recipes\")\n    .update({ is_active: false })\n    .eq(\"store_id\", store_id)\n    .eq(\"output_item_id\", outputItemId)\n    .neq(\"id\", recipe.id); // Exclude the new one\n\n  if (deactivateError) {\n    console.error(\"Failed to deactivate old recipes:\", deactivateError);\n  }\n\n  revalidatePath(\"/dashboard/recipes\");\n  return { success: true, recipeId: recipe.id };\n}\n\nexport async function calculateRecipeCost(items: RecipeItemInput[]) {\n  const supabase = await createClient();\n  let totalCost = 0;\n\n  // Fetch prices for all items\n  const itemIds = items.map((i) => i.inputItemId);\n  const { data: dbItems } = await supabase\n    .from(\"items\")\n    .select(\"id, base_unit, latest_purchase_price\")\n    .in(\"id\", itemIds);\n\n  if (!dbItems) return 0;\n\n  for (const item of items) {\n    const dbItem = dbItems.find((i) => i.id === item.inputItemId);\n    if (!dbItem || !dbItem.latest_purchase_price) continue;\n\n    // Convert unit\n    // We call the DB function for accurate conversion\n    const { data: convertedQty } = await supabase.rpc(\"convert_unit\", {\n      p_quantity: item.quantity,\n      p_from_unit: item.unit,\n      p_to_unit: dbItem.base_unit,\n      p_item_id: item.inputItemId\n    });\n\n    if (convertedQty !== null) {\n      totalCost += (convertedQty as number) * dbItem.latest_purchase_price;\n    }\n  }\n\n  return totalCost;\n}\n\nexport async function getRecipes() {\n  const supabase = await createClient();\n  const { data: { user } } = await supabase.auth.getUser();\n  if (!user) return [];\n\n  const { data: userRole } = await supabase\n    .from(\"user_roles\")\n    .select(\"store_id\")\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (!userRole?.store_id) return [];\n\n  const { data } = await supabase\n    .from(\"recipes\")\n    .select(`\n      *,\n      output_item:items!output_item_id(name, code, base_unit),\n      recipe_items(\n        quantity,\n        unit,\n        input_item:items!input_item_id(name, base_unit, latest_purchase_price)\n      )\n    `)\n    .eq(\"store_id\", userRole.store_id)\n    .eq(\"is_active\", true)\n    .order(\"created_at\", { ascending: false });\n\n  return data || [];\n}","export {getRecipes as '005e74f9cabeaa4c50f6d31fcc0d11a9eb8a2554e9'} from 'ACTIONS_MODULE0'\nexport {createRecipe as '4057c0cbc5ca48737df82f1073933b664183b4c1e9'} from 'ACTIONS_MODULE0'\nexport {calculateRecipeCost as '40db8656ca4dd856b0cf87c27963b45d24b1859875'} from 'ACTIONS_MODULE0'\n"],"names":["registerServerReference","ensureServerEntryExports","actions","i","length","action","Error"],"mappings":"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","ignoreList":[0,1]}