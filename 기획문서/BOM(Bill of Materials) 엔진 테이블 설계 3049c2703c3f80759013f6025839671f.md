# BOM(Bill of Materials) 엔진 테이블 설계

## 목차

1. [설계 철학](https://claude.ai/chat/fadf1908-5a16-4df3-b390-ee6d40ea1017#1-%EC%84%A4%EA%B3%84-%EC%B2%A0%ED%95%99)
2. [핵심 테이블 구조](https://claude.ai/chat/fadf1908-5a16-4df3-b390-ee6d40ea1017#2-%ED%95%B5%EC%8B%AC-%ED%85%8C%EC%9D%B4%EB%B8%94-%EA%B5%AC%EC%A1%B0)
3. [다단계 BOM 처리](https://claude.ai/chat/fadf1908-5a16-4df3-b390-ee6d40ea1017#3-%EB%8B%A4%EB%8B%A8%EA%B3%84-bom-%EC%B2%98%EB%A6%AC)
4. [단위 변환 시스템](https://claude.ai/chat/fadf1908-5a16-4df3-b390-ee6d40ea1017#4-%EB%8B%A8%EC%9C%84-%EB%B3%80%ED%99%98-%EC%8B%9C%EC%8A%A4%ED%85%9C)
5. [실전 쿼리 예시](https://claude.ai/chat/fadf1908-5a16-4df3-b390-ee6d40ea1017#5-%EC%8B%A4%EC%A0%84-%EC%BF%BC%EB%A6%AC-%EC%98%88%EC%8B%9C)
6. [원가 계산 로직](https://claude.ai/chat/fadf1908-5a16-4df3-b390-ee6d40ea1017#6-%EC%9B%90%EA%B0%80-%EA%B3%84%EC%82%B0-%EB%A1%9C%EC%A7%81)
7. [성능 최적화](https://claude.ai/chat/fadf1908-5a16-4df3-b390-ee6d40ea1017#7-%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94)

---

## 1. 설계 철학

### 베이커리/카페의 특수성

```
원자재 (밀가루, 버터, 설탕)
    ↓ 1차 가공
반제품 (크로와상 생지, 우유거품)
    ↓ 2차 가공
완제품 (구운 크로와상, 카페라떼)
    ↓ 옵션 추가
최종 판매품 (크로와상 + 샷추가 카페라떼)
```

### 설계 원칙

- **재귀적 구조**: 반제품이 다시 재료가 될 수 있음
- **유연한 단위**: kg, g, ea, box, ml 등 다양한 단위 지원
- **옵션 처리**: 샷 추가, 휘핑 변경 등 커스터마이징 대응
- **버전 관리**: 레시피 변경 이력 추적

---

## 2. 핵심 테이블 구조

### 2.1 Items (품목 마스터)

모든 것(원자재, 반제품, 완제품)을 통합 관리

```sql
CREATE TYPE item_type AS ENUM ('raw', 'semi_finished', 'finished');
CREATE TYPE unit_type AS ENUM ('kg', 'g', 'l', 'ml', 'ea', 'box', 'pack');

CREATE TABLE items (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  store_id UUID NOT NULL REFERENCES stores(id) ON DELETE CASCADE,

  -- 기본 정보
  code VARCHAR(50), -- 품목 코드 (SKU)
  name VARCHAR(255) NOT NULL,
  name_en VARCHAR(255), -- 영문명 (옵션)

  -- 분류
  type item_type NOT NULL, -- 'raw', 'semi_finished', 'finished'
  category_id UUID REFERENCES categories(id),

  -- 단위 정보
  base_unit unit_type NOT NULL, -- 기준 단위
  purchase_unit unit_type, -- 구매 단위 (kg로 사지만 g로 사용)

  -- 가격 정보
  sale_price DECIMAL(10, 2), -- 판매가 (finished만 해당)
  latest_purchase_price DECIMAL(10, 2), -- 최근 매입가 (raw만 해당)

  -- 재고 관리
  is_inventory_managed BOOLEAN DEFAULT true, -- 재고 추적 여부
  safety_stock DECIMAL(10, 3), -- 안전 재고

  -- 메타데이터
  description TEXT,
  image_url TEXT,
  is_active BOOLEAN DEFAULT true,

  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- 인덱스
CREATE INDEX idx_items_store ON items(store_id);
CREATE INDEX idx_items_type ON items(store_id, type);
CREATE INDEX idx_items_code ON items(store_id, code);

-- 예시 데이터
/*
원자재:
- id: 'aaa...', type: 'raw', name: '박력분', base_unit: 'kg'
- id: 'bbb...', type: 'raw', name: '버터', base_unit: 'kg'

반제품:
- id: 'ccc...', type: 'semi_finished', name: '크로와상 생지', base_unit: 'ea'

완제품:
- id: 'ddd...', type: 'finished', name: '크로와상', base_unit: 'ea', sale_price: 4500
*/
```

### 2.2 Categories (카테고리)

```sql
CREATE TABLE categories (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  store_id UUID NOT NULL REFERENCES stores(id) ON DELETE CASCADE,

  name VARCHAR(100) NOT NULL,
  parent_id UUID REFERENCES categories(id), -- 계층 구조 지원

  display_order INT DEFAULT 0,

  created_at TIMESTAMP DEFAULT NOW()
);

-- 예시
/*
음료
  ├── 커피
  ├── 논커피
  └── 차
빵
  ├── 하드계열
  ├── 소프트계열
  └── 페이스트리
*/
```

### 2.3 Recipes (BOM - 레시피)

품목 간의 재료 구성 관계

```sql
CREATE TABLE recipes (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  store_id UUID NOT NULL REFERENCES stores(id) ON DELETE CASCADE,

  -- 생산할 품목
  output_item_id UUID NOT NULL REFERENCES items(id) ON DELETE CASCADE,
  output_quantity DECIMAL(10, 3) NOT NULL DEFAULT 1, -- 1회 생산량

  -- 버전 관리
  version INT NOT NULL DEFAULT 1,
  is_active BOOLEAN DEFAULT true, -- 현재 사용 중인 레시피

  -- 메타데이터
  name VARCHAR(255), -- "크로와상 레시피 v2"
  description TEXT,
  notes TEXT, -- 조리법, 주의사항

  created_by UUID REFERENCES users(id),
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),

  UNIQUE(store_id, output_item_id, version)
);

-- 인덱스
CREATE INDEX idx_recipes_output ON recipes(output_item_id);
CREATE INDEX idx_recipes_active ON recipes(store_id, output_item_id, is_active);
```

### 2.4 Recipe_Items (BOM 상세)

레시피에 들어가는 재료 목록

```sql
CREATE TABLE recipe_items (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  recipe_id UUID NOT NULL REFERENCES recipes(id) ON DELETE CASCADE,

  -- 투입할 재료
  input_item_id UUID NOT NULL REFERENCES items(id) ON DELETE RESTRICT,
  quantity DECIMAL(10, 3) NOT NULL, -- 소요량
  unit unit_type NOT NULL, -- 사용 단위

  -- 추가 정보
  sort_order INT DEFAULT 0, -- UI 표시 순서
  is_optional BOOLEAN DEFAULT false, -- 선택 재료 여부
  notes TEXT, -- "잘 섞을 것"

  created_at TIMESTAMP DEFAULT NOW()
);

-- 인덱스
CREATE INDEX idx_recipe_items_recipe ON recipe_items(recipe_id);
CREATE INDEX idx_recipe_items_input ON recipe_items(input_item_id);

-- 예시 데이터
/*
크로와상 레시피 (1개 생산 기준):
- recipe_id: 'xxx', input_item: '박력분', quantity: 50, unit: 'g'
- recipe_id: 'xxx', input_item: '버터', quantity: 25, unit: 'g'
- recipe_id: 'xxx', input_item: '설탕', quantity: 5, unit: 'g'
*/
```

---

## 3. 다단계 BOM 처리

### 3.1 BOM 계층 구조 예시

```
[완제품] 카페라떼 (1잔)
  ├── [반제품] 에스프레소 샷 (2샷)
  │     ├── [원자재] 원두 (18g)
  │     └── [원자재] 물 (60ml)
  └── [반제품] 스팀밀크 (200ml)
        ├── [원자재] 우유 (200ml)
        └── [원자재] 바닐라 시럽 (10ml) [옵션]
```

### 3.2 재귀 쿼리로 전체 BOM 펼치기

```sql
-- 카페라떼의 모든 원자재 추적 (재귀 CTE)
WITH RECURSIVE bom_tree AS (
  -- 1단계: 직접 재료
  SELECT
    ri.recipe_id,
    ri.input_item_id,
    i.name AS item_name,
    i.type AS item_type,
    ri.quantity,
    ri.unit,
    1 AS level,
    ri.quantity AS total_quantity
  FROM recipe_items ri
  JOIN items i ON i.id = ri.input_item_id
  WHERE ri.recipe_id = '카페라떼_recipe_id'

  UNION ALL

  -- 2단계 이상: 재료의 재료
  SELECT
    ri.recipe_id,
    ri.input_item_id,
    i.name,
    i.type,
    ri.quantity,
    ri.unit,
    bt.level + 1,
    bt.total_quantity * ri.quantity -- 누적 수량 계산
  FROM bom_tree bt
  JOIN recipes r ON r.output_item_id = bt.input_item_id AND r.is_active = true
  JOIN recipe_items ri ON ri.recipe_id = r.id
  JOIN items i ON i.id = ri.input_item_id
  WHERE bt.item_type != 'raw' -- 원자재가 아니면 계속 탐색
)
SELECT
  item_name,
  item_type,
  SUM(total_quantity) AS required_quantity,
  unit
FROM bom_tree
WHERE item_type = 'raw' -- 최종적으로 원자재만 집계
GROUP BY item_name, item_type, unit;

-- 결과:
-- 원두: 18g
-- 물: 60ml
-- 우유: 200ml
-- 바닐라 시럽: 10ml
```

---

## 4. 단위 변환 시스템

### 4.1 Unit_Conversions (단위 변환 테이블)

```sql
CREATE TABLE unit_conversions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

  from_unit unit_type NOT NULL,
  to_unit unit_type NOT NULL,
  conversion_factor DECIMAL(15, 6) NOT NULL, -- from * factor = to

  -- 품목별 특수 변환 (옵션)
  item_id UUID REFERENCES items(id), -- NULL이면 범용 변환

  created_at TIMESTAMP DEFAULT NOW(),

  UNIQUE(from_unit, to_unit, item_id)
);

-- 예시 데이터
INSERT INTO unit_conversions (from_unit, to_unit, conversion_factor) VALUES
  ('kg', 'g', 1000),
  ('l', 'ml', 1000),
  ('box', 'ea', 12), -- 1박스 = 12개 (품목별로 다를 수 있음)
  ('pack', 'g', 500); -- 1팩 = 500g (우유 팩 등)

-- 품목별 특수 변환
-- 버터 1박스 = 20kg
INSERT INTO unit_conversions (from_unit, to_unit, conversion_factor, item_id)
VALUES ('box', 'kg', 20, '버터_item_id');
```

### 4.2 변환 함수

```sql
CREATE OR REPLACE FUNCTION convert_unit(
  p_quantity DECIMAL,
  p_from_unit unit_type,
  p_to_unit unit_type,
  p_item_id UUID DEFAULT NULL
) RETURNS DECIMAL AS $$
DECLARE
  v_factor DECIMAL;
BEGIN
  -- 같은 단위면 그대로 반환
  IF p_from_unit = p_to_unit THEN
    RETURN p_quantity;
  END IF;

  -- 품목별 특수 변환 우선
  SELECT conversion_factor INTO v_factor
  FROM unit_conversions
  WHERE from_unit = p_from_unit
    AND to_unit = p_to_unit
    AND item_id = p_item_id;

  -- 없으면 범용 변환
  IF v_factor IS NULL THEN
    SELECT conversion_factor INTO v_factor
    FROM unit_conversions
    WHERE from_unit = p_from_unit
      AND to_unit = p_to_unit
      AND item_id IS NULL;
  END IF;

  IF v_factor IS NULL THEN
    RAISE EXCEPTION 'No conversion found: % to %', p_from_unit, p_to_unit;
  END IF;

  RETURN p_quantity * v_factor;
END;
$$ LANGUAGE plpgsql;

-- 사용 예시
SELECT convert_unit(2.5, 'kg', 'g'); -- 2500
SELECT convert_unit(1, 'box', 'kg', '버터_item_id'); -- 20
```

---

## 5. 실전 쿼리 예시

### 5.1 제품의 이론 원가 계산

```sql
CREATE OR REPLACE FUNCTION calculate_product_cost(p_item_id UUID)
RETURNS TABLE(
  raw_material VARCHAR,
  quantity DECIMAL,
  unit VARCHAR,
  unit_price DECIMAL,
  total_cost DECIMAL
) AS $$
BEGIN
  RETURN QUERY
  WITH RECURSIVE bom_explosion AS (
    -- 초기: 제품의 직접 재료
    SELECT
      ri.input_item_id,
      ri.quantity,
      ri.unit,
      1 AS level
    FROM recipes r
    JOIN recipe_items ri ON ri.recipe_id = r.id
    WHERE r.output_item_id = p_item_id
      AND r.is_active = true

    UNION ALL

    -- 재귀: 반제품의 재료
    SELECT
      ri.input_item_id,
      be.quantity * ri.quantity, -- 수량 곱셈
      ri.unit,
      be.level + 1
    FROM bom_explosion be
    JOIN items i ON i.id = be.input_item_id
    JOIN recipes r ON r.output_item_id = i.id AND r.is_active = true
    JOIN recipe_items ri ON ri.recipe_id = r.id
    WHERE i.type != 'raw' -- 원자재가 아니면 계속
  )
  SELECT
    i.name,
    SUM(be.quantity),
    be.unit::VARCHAR,
    i.latest_purchase_price,
    SUM(be.quantity) * i.latest_purchase_price
  FROM bom_explosion be
  JOIN items i ON i.id = be.input_item_id
  WHERE i.type = 'raw'
  GROUP BY i.name, be.unit, i.latest_purchase_price;
END;
$$ LANGUAGE plpgsql;

-- 실행
SELECT * FROM calculate_product_cost('크로와상_item_id');

-- 결과:
-- 박력분, 50, g, 0.005, 0.25
-- 버터, 25, g, 0.015, 0.375
-- 설탕, 5, g, 0.003, 0.015
-- → 총 원가: 0.64원
```

### 5.2 판매량 기반 재료 소진량 계산

```sql
-- 오늘 판매된 제품으로 소진된 원자재 집계
WITH todays_sales AS (
  SELECT
    si.item_id,
    SUM(si.quantity) AS sold_quantity
  FROM sales s
  JOIN sales_items si ON si.sale_id = s.id
  WHERE s.sale_date = CURRENT_DATE
    AND s.store_id = '특정_매장_id'
  GROUP BY si.item_id
)
SELECT
  i.name AS raw_material,
  SUM(ts.sold_quantity * calc.quantity) AS consumed,
  calc.unit
FROM todays_sales ts
CROSS JOIN LATERAL calculate_product_cost(ts.item_id) AS calc
JOIN items i ON i.name = calc.raw_material
GROUP BY i.name, calc.unit;

-- 결과:
-- 원두: 3600g (200잔 × 18g)
-- 우유: 40000ml (200잔 × 200ml)
```

---

## 6. 원가 계산 로직

### 6.1 실제 원가 vs 이론 원가

```sql
CREATE TABLE cost_analysis (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  store_id UUID NOT NULL REFERENCES stores(id),

  analysis_date DATE NOT NULL,
  item_id UUID REFERENCES items(id),

  -- 이론 원가
  theoretical_cost DECIMAL(10, 2), -- BOM 기준 계산

  -- 실제 원가
  actual_cost DECIMAL(10, 2), -- 실제 매입가 기준

  -- 차이
  variance DECIMAL(10, 2), -- actual - theoretical
  variance_percent DECIMAL(5, 2), -- (variance / theoretical) * 100

  -- 분석
  notes TEXT,

  created_at TIMESTAMP DEFAULT NOW()
);

-- 일별 원가 분석 자동 생성 함수
CREATE OR REPLACE FUNCTION analyze_daily_cost(p_store_id UUID, p_date DATE)
RETURNS VOID AS $$
BEGIN
  INSERT INTO cost_analysis (
    store_id,
    analysis_date,
    item_id,
    theoretical_cost,
    actual_cost,
    variance,
    variance_percent
  )
  SELECT
    p_store_id,
    p_date,
    i.id,
    (SELECT SUM(total_cost) FROM calculate_product_cost(i.id)),
    -- 실제 원가 계산 (실사 기반)
    -- 여기서는 간단히 이론원가 * 1.05로 가정 (5% 로스)
    (SELECT SUM(total_cost) FROM calculate_product_cost(i.id)) * 1.05,
    (SELECT SUM(total_cost) FROM calculate_product_cost(i.id)) * 0.05,
    5.0
  FROM items i
  WHERE i.store_id = p_store_id
    AND i.type = 'finished';
END;
$$ LANGUAGE plpgsql;
```

### 6.2 옵션별 추가 원가 계산

```sql
CREATE TABLE item_options (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  item_id UUID NOT NULL REFERENCES items(id) ON DELETE CASCADE,

  option_name VARCHAR(100) NOT NULL, -- "샷 추가", "휘핑 추가"
  option_value VARCHAR(100), -- "1샷", "2샷"

  -- 추가 재료
  additional_ingredient_id UUID REFERENCES items(id),
  additional_quantity DECIMAL(10, 3),
  additional_unit unit_type,

  -- 추가 가격
  price_adjustment DECIMAL(10, 2) DEFAULT 0,

  created_at TIMESTAMP DEFAULT NOW()
);

-- 예시
/*
카페라떼 + 샷추가:
- item_id: '카페라떼', option_name: '샷추가', option_value: '1샷'
- additional_ingredient: '에스프레소샷', additional_quantity: 1, unit: 'ea'
- price_adjustment: 500 (500원 추가)
*/

-- 옵션 포함 원가 계산
SELECT
  i.name,
  (SELECT SUM(total_cost) FROM calculate_product_cost(i.id)) AS base_cost,
  COALESCE(SUM(
    (SELECT latest_purchase_price FROM items WHERE id = io.additional_ingredient_id)
    * io.additional_quantity
  ), 0) AS option_cost
FROM items i
LEFT JOIN item_options io ON io.item_id = i.id
WHERE i.id = '카페라떼_id'
GROUP BY i.name, i.id;
```

---

## 7. 성능 최적화

### 7.1 머티리얼라이즈드 뷰 (Materialized View)

자주 조회하는 BOM 데이터를 미리 계산

```sql
-- 전체 BOM 플랫 뷰
CREATE MATERIALIZED VIEW mv_flattened_bom AS
WITH RECURSIVE bom_tree AS (
  SELECT
    r.output_item_id AS product_id,
    ri.input_item_id AS material_id,
    ri.quantity,
    ri.unit,
    1 AS level
  FROM recipes r
  JOIN recipe_items ri ON ri.recipe_id = r.id
  WHERE r.is_active = true

  UNION ALL

  SELECT
    bt.product_id,
    ri.input_item_id,
    bt.quantity * ri.quantity,
    ri.unit,
    bt.level + 1
  FROM bom_tree bt
  JOIN items i ON i.id = bt.material_id
  JOIN recipes r ON r.output_item_id = i.id AND r.is_active = true
  JOIN recipe_items ri ON ri.recipe_id = r.id
  WHERE i.type != 'raw'
)
SELECT
  bt.product_id,
  p.name AS product_name,
  bt.material_id,
  m.name AS material_name,
  SUM(bt.quantity) AS total_quantity,
  bt.unit
FROM bom_tree bt
JOIN items p ON p.id = bt.product_id
JOIN items m ON m.id = bt.material_id
WHERE m.type = 'raw'
GROUP BY bt.product_id, p.name, bt.material_id, m.name, bt.unit;

-- 인덱스
CREATE INDEX idx_mv_bom_product ON mv_flattened_bom(product_id);

-- 정기 갱신 (스케줄러)
REFRESH MATERIALIZED VIEW mv_flattened_bom;

-- 사용 예시 (매우 빠름)
SELECT * FROM mv_flattened_bom WHERE product_id = '크로와상_id';
```

### 7.2 캐싱 전략

```tsx
// Next.js API Route
// app/api/items/[id]/cost/route.ts
import { unstable_cache } from 'next/cache'

export const GET = unstable_cache(
  async (id: string) => {
    const cost = await calculateProductCost(id)
    return Response.json(cost)
  },
  ['product-cost'], // 캐시 키
  {
    revalidate: 3600, // 1시간마다 갱신
    tags: ['bom'] // 레시피 변경 시 무효화
  }
)
```

---

## 8. 레시피 빌더 UI 스펙

### 8.1 필수 기능

```tsx
interface RecipeBuilderProps {
  mode: 'create' | 'edit'
  itemId?: string // edit 모드일 때
}

// 주요 기능
- 드래그 앤 드롭으로 재료 추가
- 수량/단위 인라인 편집
- 실시간 원가 계산 미리보기
- 다단계 BOM 시각화 (트리 구조)
- 버전 비교 (v1 vs v2)
- 엑셀 일괄 업로드/다운로드
```

### 8.2 엑셀 템플릿 예시

```
| 제품명 | 재료명 | 수량 | 단위 | 비고 |
|--------|--------|------|------|------|
| 크로와상 | 박력분 | 50 | g | |
| 크로와상 | 버터 | 25 | g | 무염버터 |
| 크로와상 | 설탕 | 5 | g | |
| 에스프레소 | 원두 | 18 | g | 로스팅 원두 |
```

---

## 9. 마이그레이션 체크리스트

### 2주차 목표

- [ ]  items 테이블 생성
- [ ]  categories 테이블 생성
- [ ]  recipes, recipe_items 테이블 생성
- [ ]  unit_conversions 테이블 생성 + 기본 데이터 삽입
- [ ]  item_options 테이블 생성

### 함수 및 뷰

- [ ]  convert_unit() 함수 생성
- [ ]  calculate_product_cost() 함수 생성
- [ ]  mv_flattened_bom 뷰 생성

### 테스트 데이터

- [ ]  샘플 원자재 10개 삽입
- [ ]  샘플 반제품 3개 삽입
- [ ]  샘플 완제품 5개 삽입
- [ ]  크로와상 레시피 생성 (3단계 BOM)

---

## 10. 실전 시나리오

### 시나리오 1: 신메뉴 레시피 등록

1. 제품 마스터에 "아인슈페너" 등록 (finished)
2. 레시피 생성:
    - 에스프레소 2샷
    - 생크림 50ml
    - 시럽 10ml
3. 자동으로 원가 계산됨
4. 판매가 설정 → 마진율 확인

### 시나리오 2: 레시피 개선

1. 기존 "크로와상" 레시피 조회 (version 1)
2. 버터 양 25g → 30g 변경
3. 새 버전 저장 (version 2)
4. 이전 버전과 원가 비교
5. 승인 후 is_active 변경

### 시나리오 3: 대량 판매 후 재료 차감

1. 오늘 크로와상 100개 판매
2. BOM 조회:
    - 박력분 5000g
    - 버터 2500g
3. 재고 테이블에서 자동 차감
4. 안전재고 이하 시 알림 발송

---

## 11. 다음 단계 (3주차 연계)

2주차에서 BOM 엔진을 완성했다면, 3주차에는:

- **데이터 수집 자동화** (크롤러 서버 분리)
- **실제 POS/배민 데이터와 BOM 연동**
- **판매 → 재고 차감 파이프라인 구축**

BOM 엔진이 제대로 작동해야 재고 추적이 가능합니다!

---

## 부록: SQL 스크립트 전체

### 전체 생성 스크립트

```sql
-- 1. ENUM 타입
CREATE TYPE item_type AS ENUM ('raw', 'semi_finished', 'finished');
CREATE TYPE unit_type AS ENUM ('kg', 'g', 'l', 'ml', 'ea', 'box', 'pack');

-- 2. 테이블
-- (위에서 정의한 모든 테이블 순서대로 실행)

-- 3. 함수
-- convert_unit()
-- calculate_product_cost()

-- 4. 뷰
-- mv_flattened_bom

-- 5. 인덱스
-- (각 테이블 하단에 정의된 인덱스)

-- 6. RLS 정책
ALTER TABLE items ENABLE ROW LEVEL SECURITY;
CREATE POLICY items_select ON items FOR SELECT
  USING (store_id IN (SELECT store_id FROM user_roles WHERE user_id = auth.uid()));

-- (모든 테이블에 동일하게 적용)
```

---

## 결론

이 BOM 엔진은:

- ✅ **N단계 레시피** 지원 (원자재 → 반제품 → 완제품)
- ✅ **정밀한 단위 변환** (kg, g, box 등)
- ✅ **재귀 쿼리로 실시간 원가 계산**
- ✅ **옵션별 추가 원가 추적**
- ✅ **성능 최적화** (Materialized View)

다음은 이 BOM 데이터를 활용한 **재고 차감 엔진**을 만들 차례입니다!